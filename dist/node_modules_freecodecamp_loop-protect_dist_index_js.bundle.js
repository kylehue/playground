"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["node_modules_freecodecamp_loop-protect_dist_index_js"],{

/***/ "./node_modules/@freecodecamp/loop-protect/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@freecodecamp/loop-protect/dist/index.js ***!
  \***************************************************************/
/***/ ((module) => {



var generateStartVar = function generateStartVar(t, id) {
  return t.variableDeclaration("var", [t.variableDeclarator(id, t.callExpression(t.memberExpression(t.identifier("Date"), t.identifier("now")), []))]);
};

var generateCounter = function generateCounter(t, id) {
  return t.variableDeclaration("var", [t.variableDeclarator(id, t.numericLiteral(1))]);
};

var generateDateComparison = function generateDateComparison() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      t = _ref.t,
      id = _ref.id,
      line = _ref.line,
      ch = _ref.ch,
      timeout = _ref.timeout,
      extra = _ref.extra,
      isLoop = _ref.isLoop;

  return t.ifStatement(generateTimeoutElapsed({
    t: t,
    id: id,
    timeout: timeout
  }), extra ? generateExtra({
    t: t,
    extra: extra,
    line: line,
    ch: ch,
    isLoop: isLoop
  }) : isLoop ? t.breakStatement() : t.returnStatement());
};

var generateTimeoutElapsed = function generateTimeoutElapsed() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      t = _ref2.t,
      id = _ref2.id,
      timeout = _ref2.timeout;

  return t.binaryExpression(">", t.binaryExpression("-", t.callExpression(t.memberExpression(t.identifier("Date"), t.identifier("now")), []), id), t.numericLiteral(timeout));
};

var generateExtra = function generateExtra() {
  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      t = _ref3.t,
      extra = _ref3.extra,
      line = _ref3.line,
      ch = _ref3.ch,
      isLoop = _ref3.isLoop;

  return t.blockStatement([t.expressionStatement(t.callExpression(extra, [t.numericLiteral(line), t.numericLiteral(ch)])), isLoop ? t.breakStatement() : t.returnStatement()]);
};

var generateInside = function generateInside() {
  var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      t = _ref4.t,
      id = _ref4.id,
      counterId = _ref4.counterId,
      line = _ref4.line,
      ch = _ref4.ch,
      timeout = _ref4.timeout,
      extra = _ref4.extra,
      iterations = _ref4.iterations,
      isLoop = _ref4.isLoop;

  return iterations ? t.ifStatement(t.logicalExpression("&&", t.binaryExpression("===", t.binaryExpression("%", t.updateExpression("++", counterId), t.numericLiteral(iterations)), t.numericLiteral(0)), generateTimeoutElapsed({
    t: t,
    id: id,
    timeout: timeout
  })), extra ? generateExtra({
    t: t,
    extra: extra,
    line: line,
    ch: ch,
    isLoop: isLoop
  }) : t.breakStatement()) : generateDateComparison({
    t: t,
    id: id,
    line: line,
    ch: ch,
    timeout: timeout,
    extra: extra,
    isLoop: isLoop
  });
};

var protect = function protect(t, timeout, extra, iterations) {
  return function (path) {
    var _body$container, _body$container2, _body$container2$decl, _body$container2$decl2, _body$container2$decl3;

    if (!path.node.loc) {
      // I don't really know _how_ we get into this state
      // but https://jsbin.com/mipesawapi/1/ triggers it
      // and the node, I'm guessing after translation,
      // doesn't have a line in the code, so this blows up.
      return;
    }

    var isLoop = t.isWhileStatement(path) || t.isForStatement(path) || t.isDoWhileStatement(path);
    var id = path.scope.generateUidIdentifier("LP");
    var counterId = path.scope.generateUidIdentifier("LPC");
    var counterVar = generateCounter(t, counterId);
    var startVar = generateStartVar(t, id);
    var inside = generateInside({
      t: t,
      id: id,
      counterId: counterId,
      line: path.node.loc.start.line,
      ch: path.node.loc.start.column,
      timeout: timeout,
      extra: extra,
      iterations: iterations,
      isLoop: isLoop
    });
    var body = path.get("body"); // For Loop Protection

    if (isLoop) {
      if (!t.isBlockStatement(body)) {
        body.replaceWith(t.blockStatement([body.node]));
      }

      path.insertBefore(counterVar);
      path.insertBefore(startVar);
      body.unshiftContainer("body", inside);
    } // For Variable Declarations
    else if ((body === null || body === void 0 ? void 0 : (_body$container = body.container) === null || _body$container === void 0 ? void 0 : _body$container.type) === "VariableDeclaration" && (body === null || body === void 0 ? void 0 : (_body$container2 = body.container) === null || _body$container2 === void 0 ? void 0 : (_body$container2$decl = _body$container2.declarations) === null || _body$container2$decl === void 0 ? void 0 : (_body$container2$decl2 = _body$container2$decl[0]) === null || _body$container2$decl2 === void 0 ? void 0 : (_body$container2$decl3 = _body$container2$decl2.init) === null || _body$container2$decl3 === void 0 ? void 0 : _body$container2$decl3.type) === "ArrowFunctionExpression") {
        var _body$container3, _body$container3$decl, _body$container3$decl2, _body$container3$decl3, _body$container3$decl4;

        path.insertBefore(counterVar);
        path.insertBefore(startVar);
        var ele = body === null || body === void 0 ? void 0 : (_body$container3 = body.container) === null || _body$container3 === void 0 ? void 0 : (_body$container3$decl = _body$container3.declarations) === null || _body$container3$decl === void 0 ? void 0 : (_body$container3$decl2 = _body$container3$decl[0]) === null || _body$container3$decl2 === void 0 ? void 0 : (_body$container3$decl3 = _body$container3$decl2.init) === null || _body$container3$decl3 === void 0 ? void 0 : (_body$container3$decl4 = _body$container3$decl3.body) === null || _body$container3$decl4 === void 0 ? void 0 : _body$container3$decl4.body;

        if (ele !== null && ele !== void 0 && ele.length) {
          ele.unshift(inside);
        }
      } // For Class Declarations
      else if (t.isClassBody(body)) {
          var _body$node, _body$node$body, _body$node$body$find, _body$node$body$find$;

          path.insertBefore(counterVar);
          path.insertBefore(startVar);

          var _ele = body === null || body === void 0 ? void 0 : (_body$node = body.node) === null || _body$node === void 0 ? void 0 : (_body$node$body = _body$node.body) === null || _body$node$body === void 0 ? void 0 : (_body$node$body$find = _body$node$body.find(function (node) {
            var _node$key;

            return (node === null || node === void 0 ? void 0 : (_node$key = node.key) === null || _node$key === void 0 ? void 0 : _node$key.name) === "render";
          })) === null || _body$node$body$find === void 0 ? void 0 : (_body$node$body$find$ = _body$node$body$find.body) === null || _body$node$body$find$ === void 0 ? void 0 : _body$node$body$find$.body;

          if (_ele !== null && _ele !== void 0 && _ele.length) {
            _ele.unshift(inside);
          }
        }
  };
};

module.exports = function () {
  var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  var extra = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var iterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var anonRegex = /^function\s*\(/;

  if (typeof extra === "string") {
    var string = extra;
    extra = "() => console.error(\"".concat(string.replace(/"/g, '\\"'), "\")");
  } else if (extra !== null) {
    extra = extra.toString();

    if (extra.match(anonRegex)) {
      // fix anonymous functions as they'll cause
      // the callback transform to blow up
      extra = extra.replace(anonRegex, "function callback(");
    }
  }

  return function (_ref5) {
    var t = _ref5.types,
        transform = _ref5.transform;
    var node = extra ? transform(extra, {
      ast: true
    }).ast.program.body[0] : null;
    var callback = null;

    if (t.isExpressionStatement(node)) {
      callback = node.expression;
    } else if (t.isFunctionDeclaration(node)) {
      callback = t.functionExpression(null, node.params, node.body);
    }

    return {
      visitor: {
        WhileStatement: protect(t, timeout, callback, iterations),
        ForStatement: protect(t, timeout, callback, iterations),
        DoWhileStatement: protect(t, timeout, callback, iterations),
        ClassDeclaration: protect(t, timeout, callback, iterations),
        VariableDeclaration: protect(t, timeout, callback, iterations)
      }
    };
  };
};

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2ZyZWVjb2RlY2FtcF9sb29wLXByb3RlY3RfZGlzdF9pbmRleF9qcy5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZyZWVjb2RlY2FtcC9sb29wLXByb3RlY3QvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGdlbmVyYXRlU3RhcnRWYXIgPSBmdW5jdGlvbiBnZW5lcmF0ZVN0YXJ0VmFyKHQsIGlkKSB7XG4gIHJldHVybiB0LnZhcmlhYmxlRGVjbGFyYXRpb24oXCJ2YXJcIiwgW3QudmFyaWFibGVEZWNsYXJhdG9yKGlkLCB0LmNhbGxFeHByZXNzaW9uKHQubWVtYmVyRXhwcmVzc2lvbih0LmlkZW50aWZpZXIoXCJEYXRlXCIpLCB0LmlkZW50aWZpZXIoXCJub3dcIikpLCBbXSkpXSk7XG59O1xuXG52YXIgZ2VuZXJhdGVDb3VudGVyID0gZnVuY3Rpb24gZ2VuZXJhdGVDb3VudGVyKHQsIGlkKSB7XG4gIHJldHVybiB0LnZhcmlhYmxlRGVjbGFyYXRpb24oXCJ2YXJcIiwgW3QudmFyaWFibGVEZWNsYXJhdG9yKGlkLCB0Lm51bWVyaWNMaXRlcmFsKDEpKV0pO1xufTtcblxudmFyIGdlbmVyYXRlRGF0ZUNvbXBhcmlzb24gPSBmdW5jdGlvbiBnZW5lcmF0ZURhdGVDb21wYXJpc29uKCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICB0ID0gX3JlZi50LFxuICAgICAgaWQgPSBfcmVmLmlkLFxuICAgICAgbGluZSA9IF9yZWYubGluZSxcbiAgICAgIGNoID0gX3JlZi5jaCxcbiAgICAgIHRpbWVvdXQgPSBfcmVmLnRpbWVvdXQsXG4gICAgICBleHRyYSA9IF9yZWYuZXh0cmEsXG4gICAgICBpc0xvb3AgPSBfcmVmLmlzTG9vcDtcblxuICByZXR1cm4gdC5pZlN0YXRlbWVudChnZW5lcmF0ZVRpbWVvdXRFbGFwc2VkKHtcbiAgICB0OiB0LFxuICAgIGlkOiBpZCxcbiAgICB0aW1lb3V0OiB0aW1lb3V0XG4gIH0pLCBleHRyYSA/IGdlbmVyYXRlRXh0cmEoe1xuICAgIHQ6IHQsXG4gICAgZXh0cmE6IGV4dHJhLFxuICAgIGxpbmU6IGxpbmUsXG4gICAgY2g6IGNoLFxuICAgIGlzTG9vcDogaXNMb29wXG4gIH0pIDogaXNMb29wID8gdC5icmVha1N0YXRlbWVudCgpIDogdC5yZXR1cm5TdGF0ZW1lbnQoKSk7XG59O1xuXG52YXIgZ2VuZXJhdGVUaW1lb3V0RWxhcHNlZCA9IGZ1bmN0aW9uIGdlbmVyYXRlVGltZW91dEVsYXBzZWQoKSB7XG4gIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICB0ID0gX3JlZjIudCxcbiAgICAgIGlkID0gX3JlZjIuaWQsXG4gICAgICB0aW1lb3V0ID0gX3JlZjIudGltZW91dDtcblxuICByZXR1cm4gdC5iaW5hcnlFeHByZXNzaW9uKFwiPlwiLCB0LmJpbmFyeUV4cHJlc3Npb24oXCItXCIsIHQuY2FsbEV4cHJlc3Npb24odC5tZW1iZXJFeHByZXNzaW9uKHQuaWRlbnRpZmllcihcIkRhdGVcIiksIHQuaWRlbnRpZmllcihcIm5vd1wiKSksIFtdKSwgaWQpLCB0Lm51bWVyaWNMaXRlcmFsKHRpbWVvdXQpKTtcbn07XG5cbnZhciBnZW5lcmF0ZUV4dHJhID0gZnVuY3Rpb24gZ2VuZXJhdGVFeHRyYSgpIHtcbiAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIHQgPSBfcmVmMy50LFxuICAgICAgZXh0cmEgPSBfcmVmMy5leHRyYSxcbiAgICAgIGxpbmUgPSBfcmVmMy5saW5lLFxuICAgICAgY2ggPSBfcmVmMy5jaCxcbiAgICAgIGlzTG9vcCA9IF9yZWYzLmlzTG9vcDtcblxuICByZXR1cm4gdC5ibG9ja1N0YXRlbWVudChbdC5leHByZXNzaW9uU3RhdGVtZW50KHQuY2FsbEV4cHJlc3Npb24oZXh0cmEsIFt0Lm51bWVyaWNMaXRlcmFsKGxpbmUpLCB0Lm51bWVyaWNMaXRlcmFsKGNoKV0pKSwgaXNMb29wID8gdC5icmVha1N0YXRlbWVudCgpIDogdC5yZXR1cm5TdGF0ZW1lbnQoKV0pO1xufTtcblxudmFyIGdlbmVyYXRlSW5zaWRlID0gZnVuY3Rpb24gZ2VuZXJhdGVJbnNpZGUoKSB7XG4gIHZhciBfcmVmNCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICB0ID0gX3JlZjQudCxcbiAgICAgIGlkID0gX3JlZjQuaWQsXG4gICAgICBjb3VudGVySWQgPSBfcmVmNC5jb3VudGVySWQsXG4gICAgICBsaW5lID0gX3JlZjQubGluZSxcbiAgICAgIGNoID0gX3JlZjQuY2gsXG4gICAgICB0aW1lb3V0ID0gX3JlZjQudGltZW91dCxcbiAgICAgIGV4dHJhID0gX3JlZjQuZXh0cmEsXG4gICAgICBpdGVyYXRpb25zID0gX3JlZjQuaXRlcmF0aW9ucyxcbiAgICAgIGlzTG9vcCA9IF9yZWY0LmlzTG9vcDtcblxuICByZXR1cm4gaXRlcmF0aW9ucyA/IHQuaWZTdGF0ZW1lbnQodC5sb2dpY2FsRXhwcmVzc2lvbihcIiYmXCIsIHQuYmluYXJ5RXhwcmVzc2lvbihcIj09PVwiLCB0LmJpbmFyeUV4cHJlc3Npb24oXCIlXCIsIHQudXBkYXRlRXhwcmVzc2lvbihcIisrXCIsIGNvdW50ZXJJZCksIHQubnVtZXJpY0xpdGVyYWwoaXRlcmF0aW9ucykpLCB0Lm51bWVyaWNMaXRlcmFsKDApKSwgZ2VuZXJhdGVUaW1lb3V0RWxhcHNlZCh7XG4gICAgdDogdCxcbiAgICBpZDogaWQsXG4gICAgdGltZW91dDogdGltZW91dFxuICB9KSksIGV4dHJhID8gZ2VuZXJhdGVFeHRyYSh7XG4gICAgdDogdCxcbiAgICBleHRyYTogZXh0cmEsXG4gICAgbGluZTogbGluZSxcbiAgICBjaDogY2gsXG4gICAgaXNMb29wOiBpc0xvb3BcbiAgfSkgOiB0LmJyZWFrU3RhdGVtZW50KCkpIDogZ2VuZXJhdGVEYXRlQ29tcGFyaXNvbih7XG4gICAgdDogdCxcbiAgICBpZDogaWQsXG4gICAgbGluZTogbGluZSxcbiAgICBjaDogY2gsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBleHRyYTogZXh0cmEsXG4gICAgaXNMb29wOiBpc0xvb3BcbiAgfSk7XG59O1xuXG52YXIgcHJvdGVjdCA9IGZ1bmN0aW9uIHByb3RlY3QodCwgdGltZW91dCwgZXh0cmEsIGl0ZXJhdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgdmFyIF9ib2R5JGNvbnRhaW5lciwgX2JvZHkkY29udGFpbmVyMiwgX2JvZHkkY29udGFpbmVyMiRkZWNsLCBfYm9keSRjb250YWluZXIyJGRlY2wyLCBfYm9keSRjb250YWluZXIyJGRlY2wzO1xuXG4gICAgaWYgKCFwYXRoLm5vZGUubG9jKSB7XG4gICAgICAvLyBJIGRvbid0IHJlYWxseSBrbm93IF9ob3dfIHdlIGdldCBpbnRvIHRoaXMgc3RhdGVcbiAgICAgIC8vIGJ1dCBodHRwczovL2pzYmluLmNvbS9taXBlc2F3YXBpLzEvIHRyaWdnZXJzIGl0XG4gICAgICAvLyBhbmQgdGhlIG5vZGUsIEknbSBndWVzc2luZyBhZnRlciB0cmFuc2xhdGlvbixcbiAgICAgIC8vIGRvZXNuJ3QgaGF2ZSBhIGxpbmUgaW4gdGhlIGNvZGUsIHNvIHRoaXMgYmxvd3MgdXAuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlzTG9vcCA9IHQuaXNXaGlsZVN0YXRlbWVudChwYXRoKSB8fCB0LmlzRm9yU3RhdGVtZW50KHBhdGgpIHx8IHQuaXNEb1doaWxlU3RhdGVtZW50KHBhdGgpO1xuICAgIHZhciBpZCA9IHBhdGguc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKFwiTFBcIik7XG4gICAgdmFyIGNvdW50ZXJJZCA9IHBhdGguc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKFwiTFBDXCIpO1xuICAgIHZhciBjb3VudGVyVmFyID0gZ2VuZXJhdGVDb3VudGVyKHQsIGNvdW50ZXJJZCk7XG4gICAgdmFyIHN0YXJ0VmFyID0gZ2VuZXJhdGVTdGFydFZhcih0LCBpZCk7XG4gICAgdmFyIGluc2lkZSA9IGdlbmVyYXRlSW5zaWRlKHtcbiAgICAgIHQ6IHQsXG4gICAgICBpZDogaWQsXG4gICAgICBjb3VudGVySWQ6IGNvdW50ZXJJZCxcbiAgICAgIGxpbmU6IHBhdGgubm9kZS5sb2Muc3RhcnQubGluZSxcbiAgICAgIGNoOiBwYXRoLm5vZGUubG9jLnN0YXJ0LmNvbHVtbixcbiAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICBleHRyYTogZXh0cmEsXG4gICAgICBpdGVyYXRpb25zOiBpdGVyYXRpb25zLFxuICAgICAgaXNMb29wOiBpc0xvb3BcbiAgICB9KTtcbiAgICB2YXIgYm9keSA9IHBhdGguZ2V0KFwiYm9keVwiKTsgLy8gRm9yIExvb3AgUHJvdGVjdGlvblxuXG4gICAgaWYgKGlzTG9vcCkge1xuICAgICAgaWYgKCF0LmlzQmxvY2tTdGF0ZW1lbnQoYm9keSkpIHtcbiAgICAgICAgYm9keS5yZXBsYWNlV2l0aCh0LmJsb2NrU3RhdGVtZW50KFtib2R5Lm5vZGVdKSk7XG4gICAgICB9XG5cbiAgICAgIHBhdGguaW5zZXJ0QmVmb3JlKGNvdW50ZXJWYXIpO1xuICAgICAgcGF0aC5pbnNlcnRCZWZvcmUoc3RhcnRWYXIpO1xuICAgICAgYm9keS51bnNoaWZ0Q29udGFpbmVyKFwiYm9keVwiLCBpbnNpZGUpO1xuICAgIH0gLy8gRm9yIFZhcmlhYmxlIERlY2xhcmF0aW9uc1xuICAgIGVsc2UgaWYgKChib2R5ID09PSBudWxsIHx8IGJvZHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfYm9keSRjb250YWluZXIgPSBib2R5LmNvbnRhaW5lcikgPT09IG51bGwgfHwgX2JvZHkkY29udGFpbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYm9keSRjb250YWluZXIudHlwZSkgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiICYmIChib2R5ID09PSBudWxsIHx8IGJvZHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfYm9keSRjb250YWluZXIyID0gYm9keS5jb250YWluZXIpID09PSBudWxsIHx8IF9ib2R5JGNvbnRhaW5lcjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfYm9keSRjb250YWluZXIyJGRlY2wgPSBfYm9keSRjb250YWluZXIyLmRlY2xhcmF0aW9ucykgPT09IG51bGwgfHwgX2JvZHkkY29udGFpbmVyMiRkZWNsID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2JvZHkkY29udGFpbmVyMiRkZWNsMiA9IF9ib2R5JGNvbnRhaW5lcjIkZGVjbFswXSkgPT09IG51bGwgfHwgX2JvZHkkY29udGFpbmVyMiRkZWNsMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ib2R5JGNvbnRhaW5lcjIkZGVjbDMgPSBfYm9keSRjb250YWluZXIyJGRlY2wyLmluaXQpID09PSBudWxsIHx8IF9ib2R5JGNvbnRhaW5lcjIkZGVjbDMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ib2R5JGNvbnRhaW5lcjIkZGVjbDMudHlwZSkgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIikge1xuICAgICAgICB2YXIgX2JvZHkkY29udGFpbmVyMywgX2JvZHkkY29udGFpbmVyMyRkZWNsLCBfYm9keSRjb250YWluZXIzJGRlY2wyLCBfYm9keSRjb250YWluZXIzJGRlY2wzLCBfYm9keSRjb250YWluZXIzJGRlY2w0O1xuXG4gICAgICAgIHBhdGguaW5zZXJ0QmVmb3JlKGNvdW50ZXJWYXIpO1xuICAgICAgICBwYXRoLmluc2VydEJlZm9yZShzdGFydFZhcik7XG4gICAgICAgIHZhciBlbGUgPSBib2R5ID09PSBudWxsIHx8IGJvZHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfYm9keSRjb250YWluZXIzID0gYm9keS5jb250YWluZXIpID09PSBudWxsIHx8IF9ib2R5JGNvbnRhaW5lcjMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfYm9keSRjb250YWluZXIzJGRlY2wgPSBfYm9keSRjb250YWluZXIzLmRlY2xhcmF0aW9ucykgPT09IG51bGwgfHwgX2JvZHkkY29udGFpbmVyMyRkZWNsID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2JvZHkkY29udGFpbmVyMyRkZWNsMiA9IF9ib2R5JGNvbnRhaW5lcjMkZGVjbFswXSkgPT09IG51bGwgfHwgX2JvZHkkY29udGFpbmVyMyRkZWNsMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ib2R5JGNvbnRhaW5lcjMkZGVjbDMgPSBfYm9keSRjb250YWluZXIzJGRlY2wyLmluaXQpID09PSBudWxsIHx8IF9ib2R5JGNvbnRhaW5lcjMkZGVjbDMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfYm9keSRjb250YWluZXIzJGRlY2w0ID0gX2JvZHkkY29udGFpbmVyMyRkZWNsMy5ib2R5KSA9PT0gbnVsbCB8fCBfYm9keSRjb250YWluZXIzJGRlY2w0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYm9keSRjb250YWluZXIzJGRlY2w0LmJvZHk7XG5cbiAgICAgICAgaWYgKGVsZSAhPT0gbnVsbCAmJiBlbGUgIT09IHZvaWQgMCAmJiBlbGUubGVuZ3RoKSB7XG4gICAgICAgICAgZWxlLnVuc2hpZnQoaW5zaWRlKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBGb3IgQ2xhc3MgRGVjbGFyYXRpb25zXG4gICAgICBlbHNlIGlmICh0LmlzQ2xhc3NCb2R5KGJvZHkpKSB7XG4gICAgICAgICAgdmFyIF9ib2R5JG5vZGUsIF9ib2R5JG5vZGUkYm9keSwgX2JvZHkkbm9kZSRib2R5JGZpbmQsIF9ib2R5JG5vZGUkYm9keSRmaW5kJDtcblxuICAgICAgICAgIHBhdGguaW5zZXJ0QmVmb3JlKGNvdW50ZXJWYXIpO1xuICAgICAgICAgIHBhdGguaW5zZXJ0QmVmb3JlKHN0YXJ0VmFyKTtcblxuICAgICAgICAgIHZhciBfZWxlID0gYm9keSA9PT0gbnVsbCB8fCBib2R5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2JvZHkkbm9kZSA9IGJvZHkubm9kZSkgPT09IG51bGwgfHwgX2JvZHkkbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ib2R5JG5vZGUkYm9keSA9IF9ib2R5JG5vZGUuYm9keSkgPT09IG51bGwgfHwgX2JvZHkkbm9kZSRib2R5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2JvZHkkbm9kZSRib2R5JGZpbmQgPSBfYm9keSRub2RlJGJvZHkuZmluZChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIF9ub2RlJGtleTtcblxuICAgICAgICAgICAgcmV0dXJuIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfbm9kZSRrZXkgPSBub2RlLmtleSkgPT09IG51bGwgfHwgX25vZGUka2V5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRrZXkubmFtZSkgPT09IFwicmVuZGVyXCI7XG4gICAgICAgICAgfSkpID09PSBudWxsIHx8IF9ib2R5JG5vZGUkYm9keSRmaW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2JvZHkkbm9kZSRib2R5JGZpbmQkID0gX2JvZHkkbm9kZSRib2R5JGZpbmQuYm9keSkgPT09IG51bGwgfHwgX2JvZHkkbm9kZSRib2R5JGZpbmQkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYm9keSRub2RlJGJvZHkkZmluZCQuYm9keTtcblxuICAgICAgICAgIGlmIChfZWxlICE9PSBudWxsICYmIF9lbGUgIT09IHZvaWQgMCAmJiBfZWxlLmxlbmd0aCkge1xuICAgICAgICAgICAgX2VsZS51bnNoaWZ0KGluc2lkZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRpbWVvdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDEwMDtcbiAgdmFyIGV4dHJhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICB2YXIgaXRlcmF0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgdmFyIGFub25SZWdleCA9IC9eZnVuY3Rpb25cXHMqXFwoLztcblxuICBpZiAodHlwZW9mIGV4dHJhID09PSBcInN0cmluZ1wiKSB7XG4gICAgdmFyIHN0cmluZyA9IGV4dHJhO1xuICAgIGV4dHJhID0gXCIoKSA9PiBjb25zb2xlLmVycm9yKFxcXCJcIi5jb25jYXQoc3RyaW5nLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSwgXCJcXFwiKVwiKTtcbiAgfSBlbHNlIGlmIChleHRyYSAhPT0gbnVsbCkge1xuICAgIGV4dHJhID0gZXh0cmEudG9TdHJpbmcoKTtcblxuICAgIGlmIChleHRyYS5tYXRjaChhbm9uUmVnZXgpKSB7XG4gICAgICAvLyBmaXggYW5vbnltb3VzIGZ1bmN0aW9ucyBhcyB0aGV5J2xsIGNhdXNlXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgdHJhbnNmb3JtIHRvIGJsb3cgdXBcbiAgICAgIGV4dHJhID0gZXh0cmEucmVwbGFjZShhbm9uUmVnZXgsIFwiZnVuY3Rpb24gY2FsbGJhY2soXCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoX3JlZjUpIHtcbiAgICB2YXIgdCA9IF9yZWY1LnR5cGVzLFxuICAgICAgICB0cmFuc2Zvcm0gPSBfcmVmNS50cmFuc2Zvcm07XG4gICAgdmFyIG5vZGUgPSBleHRyYSA/IHRyYW5zZm9ybShleHRyYSwge1xuICAgICAgYXN0OiB0cnVlXG4gICAgfSkuYXN0LnByb2dyYW0uYm9keVswXSA6IG51bGw7XG4gICAgdmFyIGNhbGxiYWNrID0gbnVsbDtcblxuICAgIGlmICh0LmlzRXhwcmVzc2lvblN0YXRlbWVudChub2RlKSkge1xuICAgICAgY2FsbGJhY2sgPSBub2RlLmV4cHJlc3Npb247XG4gICAgfSBlbHNlIGlmICh0LmlzRnVuY3Rpb25EZWNsYXJhdGlvbihub2RlKSkge1xuICAgICAgY2FsbGJhY2sgPSB0LmZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBub2RlLnBhcmFtcywgbm9kZS5ib2R5KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmlzaXRvcjoge1xuICAgICAgICBXaGlsZVN0YXRlbWVudDogcHJvdGVjdCh0LCB0aW1lb3V0LCBjYWxsYmFjaywgaXRlcmF0aW9ucyksXG4gICAgICAgIEZvclN0YXRlbWVudDogcHJvdGVjdCh0LCB0aW1lb3V0LCBjYWxsYmFjaywgaXRlcmF0aW9ucyksXG4gICAgICAgIERvV2hpbGVTdGF0ZW1lbnQ6IHByb3RlY3QodCwgdGltZW91dCwgY2FsbGJhY2ssIGl0ZXJhdGlvbnMpLFxuICAgICAgICBDbGFzc0RlY2xhcmF0aW9uOiBwcm90ZWN0KHQsIHRpbWVvdXQsIGNhbGxiYWNrLCBpdGVyYXRpb25zKSxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogcHJvdGVjdCh0LCB0aW1lb3V0LCBjYWxsYmFjaywgaXRlcmF0aW9ucylcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=